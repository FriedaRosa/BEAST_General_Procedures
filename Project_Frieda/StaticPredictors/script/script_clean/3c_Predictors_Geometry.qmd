---
title: "Predictor Variables Calculations 3"
author: "Friederike Wölke"
date: "2024-04-20"
output:
  html_document:
    code_folding: hide
format:
  html:
    toc: true
    number-sections: true
    colorlinks: true
---

# Geometries

## Clean environment
```{r}
rm(list=ls())
gc()
```

## Libraries
```{r}
pacman::p_load(dplyr, sf, rstatix, geosphere, geodata, terra, tidyterra)
sf_use_s2(FALSE)
```

## Function to calculate Geometries 
# Credits: Dr. Gabriel Ortega Solís wrote this function 
```{r} 

# Function to get the max elongation per polygon, north-south length or east-west length, circularity, etc...
poly_attr <- function(x, type = NULL) {
  # Convert "sf" to SpatVector
  if (inherits(x, "sf") == T) {
    x <- vect(x)
  }
  # Reproject to WGS84. Currently, "terra" calculate distance in meters when given latitude and longitude points.
  x <- project(x, "epsg:4326")
  # Get East-West distance (longitudinal extension)
  if (type == "ewDist") {
    vert <- crds(as.points(ext(x)), df = T)
    dimNames <- list(c("point"),c("x","y"))
    sw <- matrix(c(min(vert[["x"]]), min(vert[["y"]])), ncol = 2, dimnames = dimNames)
    se <- matrix(c(max(vert[["x"]]), min(vert[["y"]])), ncol = 2, dimnames = dimNames)
    res <- distance(sw, se, lonlat = T)[[1]]
  }
  # Get South-North distance (latitudinal extension)
  if (type == "nsDist") {
    vert <- crds(as.points(ext(x)), df = T)
    dimNames <- list(c("point"),c("x","y"))
    sw <- matrix(c(min(vert[["x"]]), min(vert[["y"]])), ncol = 2, dimnames = dimNames)
    nw <- matrix(c(min(vert[["x"]]), max(vert[["y"]])), ncol = 2, dimnames = dimNames)
    res <- distance(sw, nw, lonlat = T)[[1]]
  }
  # Get max distance between opposite vertices
  if (type == "maxDist") {
    vert <- crds(as.points(convHull(x)))
    res <- distance(vert, lonlat = T) %>% max()
  }
  # Get elongation ratio along longest axis
  if (type == "elonRatio") {
    convexHull <- convHull(x)
    vert <- crds(as.points(convexHull), df = T)
    dist <- as.data.frame.table(as.matrix(distance(vert, lonlat = T)), responseName = "distance") %>%
      slice_max(., distance)
    axisPoints <- vert[c(dist[[1]][[1]],dist[[2]][[1]]),]
    axisPoints <- arrange(axisPoints, desc(y))
    rotation <- -1*bearing(axisPoints[2,],axisPoints[1,])
    rotHull <- spin(convexHull, rotation)
    ext <- ext(convexHull)
    df <- as.vector(distance(crds(as.points(ext)), lonlat = T))
    df <- sort(df)
    length <- mean(df[[3]], df[[4]])
    width <- mean(df[[1]], df[[2]])
    res <- 1 - (width / length)
    # res <- list()
    # res[["vert"]] <- vert
    # res[["dist"]] <- dist
    # res[["axispoints"]] <- axisPoints
    # res[["bearing"]] <- rotation
    # res[["rotHull"]] <- rotHull
  }
  # Circularity
  if (type == "circ") {
    perimeter <- perim(x)
    area <- expanse(x)
    res <- (perimeter^2) / area
  }
  # Normalized circularity
  if (type == "circNorm") {
    perimeter <- perim(x)
    area <- expanse(x)
    res <- (perimeter^2) / (4 * pi * area)
  }
  # Major length of the minimum rectangle
  if (type == "lengthMinRect") {
    minRectangle <- minRect(x)
    df <- as.vector(distance(crds(as.points(minRectangle), df = T), lonlat = T))
    df <- sort(df)
    res <- mean(df[[3]], df[[4]])
  }
  # Width of the minimum rectangle
  if (type == "widthMinRect") {
    minRectangle <- minRect(x)
    df <- as.vector(distance(crds(as.points(minRectangle), df = T), lonlat = T))
    df <- sort(df)
    res <- mean(df[[1]], df[[2]])
  }
  # Elongation ratio of minimal encasing rectangle (from here: Dražić, S., Ralević, N., & Žunić, J. (2010). Shape elongation from optimal encasing rectangles. Computers & Mathematics with Applications, 60(7), 2035–2042. https://doi.org/10.1016/j.camwa.2010.07.043)
  if (type == "elonMinRect") {
    minRectangle <- minRect(x)
    df <- as.vector(distance(crds(as.points(minRectangle)), lonlat = T))
    df <- sort(df)
    length <- mean(df[[3]], df[[4]])
    width <- mean(df[[1]], df[[2]])
    res <- 1 - (width / length)
  }
  # Related circumscribing circle
  if (type == "relCirc") {
    circle <- minCircle(x)
    areaCircle <- expanse(circle)
    area <- expanse(x)
    res <- 1-(area/areaCircle)
  }
  # Linearity index
  if (type == "lin") {
    hull <- convHull(x)
    df <- crds(as.points(hull), df = T)
    lm <- lm(y ~ x, data = df)
    res <- summary(lm)$r.squared
  }
  # North bearing of the minimum rectangle
  if (type == "bearingMinRect") {
    minRectangle <- minRect(x)
    df <- crds(as.points(minRectangle), df = T)
    cor <- cor(df[["x"]],df[["y"]])
    point1 <- slice_min(df, y)
    if (cor > 0){
      point2 <-slice_max(df, x)
    } else{
      point2 <-slice_min(df, x)
    }
    res <- bearing(point1, point2)
  }
    # Get bearing along longest axis
  if (type == "bearing") {
    convexHull <- convHull(x)
    vert <- crds(as.points(convexHull), df = T)
    dist <- as.data.frame.table(as.matrix(distance(vert, lonlat = T)), responseName = "distance") %>%
      slice_max(., distance)
    axisPoints <- vert[c(dist[[1]][[1]],dist[[2]][[1]]),]
    axisPoints <- arrange(axisPoints, desc(y))
    res <- bearing(axisPoints[2,],axisPoints[1,])
  }
  res <- as.numeric(res)
  return(res)
}

```

## Data

```{r}
source_atlas <- c("c:/Users/wolke/OneDrive - CZU v Praze/Datasets/Processed/Atlases/Replicated/")
source_Git <- c("c:/Users/wolke/OneDrive - CZU v Praze/Dokumenty/GitHub/BEAST_General_Procedures/Project_Frieda/StaticPredictors/")
out_path <- c(paste0(source_Git, "out/"))

# Folder paths to atlas data
source_paths <- c(paste0(source_atlas, "Birds_Atlas_Czechia/"), 
                  paste0(source_atlas, "Birds_Atlas_New_York/"), 
                  paste0(source_atlas, "Birds_atlas_Japan/"), 
                  paste0(source_atlas, "Birds_atlas_EBBA/"))

# Folder path to output folder
out_path <- c(paste0(source_Git, "out/"))

# Paths to data & grids
data_paths <- c(paste0(source_paths[1],"Birds_Atlas_Czechia_beast_data.rds"), 
                paste0(source_paths[2], "Birds_Atlas_New_York_beast_data.rds"), 
                paste0(source_paths[3], "Birds_atlas_Japan_beast_data.rds"),
                paste0(source_paths[4], "Birds_atlas_EBBA_beast_data_CHANGE.rds"))

grid_paths <- c(paste0(source_paths[1],"Birds_Atlas_Czechia_grid.gpkg"), 
                paste0(source_paths[2], "Birds_Atlas_New_York_grid.gpkg"), 
                paste0(source_paths[3], "Birds_atlas_Japan_grid.gpkg"),
                paste0(source_paths[4], "Birds_atlas_EBBA_grid.gpkg"))

```

# Set Variables
```{r}
# Vectors for loops:
atlas_names <- c("Birds_Atlas_Czechia", "Birds_Atlas_New_York","Birds_atlas_Japan", "Birds_atlas_EBBA")
time_periods <- c(1,2)

# Define the desired order of factor levels
desired_levels <- factor(c("1", "2","4", "8", "16", "32", "64", "128"), ordered = T,  
                         levels = c("1", "2","4", "8", "16", "32", "64", "128")) 

```


# Atlas Geometries

```{r}
tictoc::tic()
# Atlas Geometries ==============================================================
geom_ls <- list()
# grid data =====================
grids <- list()
for (a in seq_along(grid_paths)) {
    grids_a <-sapply("cell1grid", function(i) {
      st_read(grid_paths[[a]], paste(i), quiet = TRUE)  %>% 
        filter(!is.na(cell_long)) %>%
        reorder_levels( cell_grouping, order=desired_levels)
      }, simplify = FALSE)
    grids[[a]] <- grids_a$cell1grid
}


for (i in seq_along(grids)){
  
  Atlas_Geom <- grids[[i]] %>% 
    select(geom, cell_label) %>%
    summarise() %>% 
    terra::vect()

    Geom_attributes_atlas <- data_frame(dataset = atlas_names[i],
           atlas_nsDist = poly_attr(Atlas_Geom, "nsDist"),
           atlas_ewDist = poly_attr(Atlas_Geom, "ewDist"),
           atlas_maxDist = poly_attr(Atlas_Geom, "maxDist"),
           atlas_lengthMinRect = poly_attr(Atlas_Geom, "lengthMinRect"),
           atlas_widthMinRect = poly_attr(Atlas_Geom, "widthMinRect"),
           atlas_elonMinRect = poly_attr(Atlas_Geom, "elonMinRect"),
           atlas_elonRatio = poly_attr(Atlas_Geom, "elonRatio"),
           atlas_circ = poly_attr(Atlas_Geom, "circ"),
           atlas_circNorm = poly_attr(Atlas_Geom, "circNorm"),
           atlas_relCirc = poly_attr(Atlas_Geom, "relCirc"),
           atlas_lin = poly_attr(Atlas_Geom, "lin"),
           atlas_bearingMinRect = poly_attr(Atlas_Geom, "bearingMinRect"), 
           atlas_bearing = poly_attr(Atlas_Geom, "bearing"))
           
  ## Southernness/Westernness
  atlas_xmin <- st_bbox(Atlas_Geom)[1] # most western point
  atlas_ymin <- st_bbox(Atlas_Geom)[2] # most southern point
  atlas_xmax <- st_bbox(Atlas_Geom)[3] # most eastern point
  atlas_ymax <- st_bbox(Atlas_Geom)[4] # most northern point
  atlas_xhalf <- atlas_xmax+(atlas_xmin-atlas_xmax)/2 # Middle point between west and east
  atlas_yhalf <- atlas_ymax+(atlas_ymin-atlas_ymax)/2 # Mittdle point between north and south
  
  atlas_bbox <- data.frame(
    atlas_xmin, atlas_xmax, atlas_xhalf, 
    atlas_ymin, atlas_ymax, atlas_yhalf)
  
  atlas_bbox$dataset <- atlas_names[i] 
  
  geom_ls[[i]] <- full_join(atlas_bbox, Geom_attributes_atlas)
  
}

countries_geom_attributes <- plyr::rbind.fill(geom_ls)


# ============================================================== #

# Transform country-borders to lines
atlas_border_lines <- list()

for (a in seq_along(grids)){
  lines <- grids[[a]] %>% 
    summarise() %>% 
    vect() %>% 
    as.lines()
  atlas_border_lines[[a]] <- lines
}

tictoc::toc()
# Clean environment
rm(a, atlas_xhalf, atlas_xmax, atlas_xmin, atlas_ymax, atlas_yhalf, atlas_ymin, grids_a, i, lines, geom_ls, atlas_bbox)


```

# Species Ranges Geometries


```{r, eval =F}
tictoc::tic()


species_geom <- list()
year_species_geom <- list()
atlas_all_sp_geom <-list()
AtlasCOG_list <- list()
AtlasCOG_all <- list()
presence_sf_list0 <- readRDS("../../out/rds/presence_sf_list.rds")

presence_sf_list0 %>% plyr::rbind.fill() %>% distinct(verbatim_name) %>% nrow()
presence_sf_list <- presence_sf_list0

for (a in seq_along(presence_sf_list)){
  atlas <- presence_sf_list[[a]] %>% 
    filter(exclude_cell == 0) %>%
    select(dataset, tp, cell_label, cell_long, cell_lat, 
    verbatim_name)

    for (y in seq_along(time_periods)){
        atlas_y <- atlas %>% filter(tp == time_periods[y])
        sp <- unique(atlas_y$verbatim_name)
    
    # Calculate center of gravity for all species in each atlas 
    AtlasCOG <- atlas_y %>% 
        st_drop_geometry() %>% 
        summarise(x = mean(cell_long),
                  y = mean(cell_lat),
                  dataset = unique(dataset)) %>% 
        vect(geom = c("x", "y"))
    AtlasCOG_list[[y]] <- atlas_y %>% 
        st_drop_geometry() %>% 
        summarise(AtlasCOG_long = mean(cell_long),
                  AtlasCOG_lat = mean(cell_lat),
                  dataset = unique(dataset))


    for (s in seq_along(sp)){
      print(paste(atlas_names[a], time_periods[y], sp[s]))
      atlas_sp <- atlas_y %>% filter(verbatim_name == sp[s]) 
      
      # Species centroids:
      sp_centroid <- atlas_sp %>% 
        st_drop_geometry() %>% 
        distinct(cell_long, cell_lat, verbatim_name, dataset, tp) %>%
        group_by(dataset, tp, verbatim_name) %>%
        summarise(
            x = mean(cell_long), 
            y = mean(cell_lat)) %>% 
        distinct() %>% 
        ungroup() %>%
        vect(geom = c("x", "y"))

        # Data to calculate geometries on:
      sp_range <- atlas_sp %>% 
          select(geom, cell_label)%>% 
          summarise() %>% 
          vect()

        # Calculate distances:
       atlas_lines <- atlas_border_lines[[a]]
       Dist_centroid_to_COG <- distance(crds(sp_centroid), crds(AtlasCOG), lonlat = T)
       minDist_toBorder_centr <- min(distance(crds(sp_centroid), crds(atlas_lines), lonlat=T))
       maxDist_toBorder_centr <- max(distance(crds(sp_centroid), crds(atlas_lines), lonlat=T))
       minDist_toBorder_border <- min(distance(crds(sp_range), crds(atlas_lines), lonlat=T))
       maxDist_toBorder_border <- max(distance(crds(sp_range), crds(atlas_lines), lonlat=T))
       
       Geom_attributes <- data_frame(dataset = atlas_names[a],
                                    tp = time_periods[y],
                                    verbatim_name = sp[s],
                                    nsDist = poly_attr(sp_range, "nsDist"),
                                    ewDist = poly_attr(sp_range, "ewDist"),
                                    maxDist = poly_attr(sp_range, "maxDist"),
                                    lengthMinRect = poly_attr(sp_range, "lengthMinRect"),
                                    widthMinRect = poly_attr(sp_range, "widthMinRect"),
                                    elonMinRect = poly_attr(sp_range, "elonMinRect"),
                                    elonRatio = poly_attr(sp_range, "elonRatio"),
                                    circ = poly_attr(sp_range, "circ"),
                                    circNorm = poly_attr(sp_range, "circNorm"),
                                    relCirc = poly_attr(sp_range, "relCirc"),
                                    lin = poly_attr(sp_range, "lin"),
                                    bearingMinRect = poly_attr(sp_range, "bearingMinRect"), 
                                    bearing = poly_attr(sp_range, "bearing"),
                                    Dist_centroid_to_COG = Dist_centroid_to_COG[1],
                                    minDist_toBorder_border = minDist_toBorder_border,
                                    maxDist_toBorder_border = maxDist_toBorder_border,
                                    minDist_toBorder_centr = minDist_toBorder_centr,
                                    maxDist_toBorder_centr = maxDist_toBorder_centr)
       
      colSums(is.na(Geom_attributes))
      Geom_attributes2 <- cbind(Geom_attributes, crds(sp_centroid))
       colSums(is.na(Geom_attributes2))
      
      
      species_geom[[s]] <- Geom_attributes2
      }

    species_geom_df <- plyr::rbind.fill(species_geom)  
    year_species_geom[[y]] <- species_geom_df 
    }
    
    AtlasCOG_all[[a]] <- plyr::rbind.fill(AtlasCOG_list)
    year_species_geom_df <- plyr::rbind.fill(year_species_geom) 
    atlas_all_sp_geom[[a]] <- year_species_geom_df
}

AtlasCOG_df <- plyr::rbind.fill(AtlasCOG_all, fill =T) 
Species_geom_attributes <- plyr::rbind.fill(atlas_all_sp_geom) %>% rename("sp_centr_lon" = "x", "sp_centr_lat" = "y")

Atlas_geom <- full_join(countries_geom_attributes, AtlasCOG_df) %>% 
    group_by(dataset) %>% 
    distinct(dataset, .keep_all=T) %>% na.omit()


Geometries <- full_join(Species_geom_attributes, Atlas_geom) %>% 
                distinct()
colSums(is.na(Geometries))

# Southerness/Westerness =================================
Southernness_Westernness <- Geometries %>% 
  group_by(dataset, tp, verbatim_name) %>% 
  select(dataset, tp, verbatim_name, sp_centr_lon, sp_centr_lat, atlas_xmin, atlas_xmax, atlas_xhalf, atlas_ymin, atlas_ymax, atlas_yhalf) %>% 
  unique() %>%
  summarize(Southernness = 1-((sp_centr_lat - atlas_ymin)/((atlas_ymax -atlas_ymin))),
            Westernness = 1-((sp_centr_lon - atlas_xmin)/((atlas_xmax-atlas_xmin)))) %>% 
  ungroup() 

Geometries_final <- left_join(Geometries, 
    Southernness_Westernness, relationship = "many-to-many") %>% 
    distinct(dataset, tp, verbatim_name, .keep_all = T)


Geometries_final2 <- Geometries_final %>% mutate(
  rel_maxDist = maxDist / atlas_maxDist,
  rel_ewDist = ewDist / atlas_ewDist,
  rel_nsDist = nsDist / atlas_nsDist,
  rel_elonRatio = elonRatio / atlas_elonRatio,
  rel_relCirc = relCirc / atlas_relCirc,
  rel_lin = lin / atlas_lin,
  rel_circNorm = circNorm / atlas_circNorm) %>% 
  select(-maxDist, -atlas_maxDist, 
         -ewDist, -atlas_ewDist, 
         -nsDist, -atlas_nsDist, 
         -elonRatio, -atlas_elonRatio, 
         -relCirc, -atlas_relCirc,
         -lin, -atlas_lin, 
         -circNorm, -atlas_circNorm)

colSums(is.na(Geometries_final2))
Geometries_final2 %>% distinct(verbatim_name) %>% nrow()
head(Geometries_final2)

Geometries_final2 %>% group_by(dataset, tp) %>% rstatix::get_summary_stats(type="mean_sd") %>% filter(sd != 0) %>% View()


saveRDS(Geometries_final2, "../../out/predictors/Geometries.rds")
save.image("../../out/RData/Geometry.RData")
tictoc::toc()
```

# No More NAs !! 