---
title: "Atlas Data Prep"
author: "Friederike WÃ¶lke"
date: "2024-03-15"
output:
  html_document:
    code_folding: hide
format:
  html:
    toc: true
    number-sections: true
    colorlinks: true
---

# ***Predicting temporal change from static patterns***

This first script is dedicated to work the atlas data and calculate AOO, OAR/D, Log response ratio, Telfer Index. In parallel, the data is iteratively checked at each step to exclude errors in data processing (Script: *`0_0_Double_Checking_DataProcessing.R`*)

# Libraries

```{r, message = F}

rm(list=ls())
gc()

# Spatial:
library(sf) 
sf_use_s2(FALSE) # switch spherical geometry off

# Data handling:
library(rstatix)
library(dplyr) 
library(tidyr) 
# library(plyr) 
## plyr is required but produces some issues with dplyr. Thus it will be called in each function individually and is not required to load here.


# Telfer calculation:
## sparta is not on CRAN and cannot be updated as usual because there is another package called sparta from CRAN but we don't want this.

# library(devtools)
# install_github('biologicalrecordscentre/sparta')
library(sparta) 

```

# Data Paths

This includes the folders to Git, the external predictor data and the atlases. We also set the desired order for the spatial grains so that they are in order from the smallest grain to the largest grain.

```{r, Variables, warning = F, message = F}

# Folders
source_atlas <- c("c:/Users/wolke/OneDrive - CZU v Praze/Datasets/Processed/Atlases/Replicated/")
source_predictors <- c("c:/Users/wolke/OneDrive - CZU v Praze/Dokumenty/PhD_Projects/StaticPredictors/Data/")
source_Git <- c("c:/Users/wolke/OneDrive - CZU v Praze/Dokumenty/GitHub/BEAST_General_Procedures/Project_Frieda/StaticPredictors/")

# Folder paths to atlas data
source_paths <- c(paste0(source_atlas, "Birds_Atlas_Czechia/"), 
                  paste0(source_atlas, "Birds_Atlas_New_York/"), 
                  paste0(source_atlas, "Birds_atlas_Japan/"), 
                  paste0(source_atlas, "Birds_atlas_EBBA/"))

# Folder path to output folder
out_path <- c(paste0(source_Git, "out/"))

# Paths to data & grids
data_paths <- c(paste0(source_paths[1],"Birds_Atlas_Czechia_beast_data.rds"), 
                paste0(source_paths[2], "Birds_Atlas_New_York_beast_data.rds"), 
                paste0(source_paths[3], "Birds_atlas_Japan_beast_data.rds"),
                paste0(source_paths[4], "Birds_atlas_EBBA_beast_data.rds"))

grid_paths <- c(paste0(source_paths[1],"Birds_Atlas_Czechia_grid.gpkg"), 
                paste0(source_paths[2], "Birds_Atlas_New_York_grid.gpkg"), 
                paste0(source_paths[3], "Birds_atlas_Japan_grid.gpkg"),
                paste0(source_paths[4], "Birds_atlas_EBBA_grid.gpkg"))

# Vectors for loops:
atlas_names <- c("Birds_Atlas_Czechia", "Birds_Atlas_New_York","Birds_atlas_Japan", "Birds_atlas_EBBA")
time_periods <- c(1,2)

# Define the desired order of factor levels
desired_levels <- factor(c("1", "2","4", "8", "16", "32", "64", "128"), ordered = T,  
                         levels = c("1", "2","4", "8", "16", "32", "64", "128")) 


```

# Read & Process Data

```{r}

# Species data  =====================
presence_data <- list()
for (i in seq_along(data_paths)){
  pres_dat <- readRDS(data_paths[i])
  sy <- sort(unique(pres_dat$start_year))
  
## Add time-period column 
  pres_dat2 <- pres_dat %>% 
    mutate(tp = case_when(start_year == sy[1] ~ 1,
                          start_year == sy[2] ~ 2)) %>% 
    filter(tp %in% c(1,2)) %>%
    reorder_levels(cell_grouping, order=desired_levels)
  presence_data[[i]] <- pres_dat2
}

# Merge list together
presence_data2 <- plyr::rbind.fill(presence_data, fill=T) %>% select(-repeated)
saveRDS(presence_data2, paste0(out_path, "rds/presence_data_raw.rds"))

rm(pres_dat, sy, pres_dat2)

```

## Reduce biases

-   remove cells that were only sampled once

-   remove species that were only sampled once in the cells that were sampled twice (because we don't have change data for them anyway).

```{r}
## Cells sampled twice 
common_cells <- presence_data2 %>% ungroup() %>%
  group_by(dataset, cell_grouping, cell_label) %>%
  mutate(num_periods_cells = n_distinct(tp)) %>%
  mutate(repeated = case_when(
    num_periods_cells == 2 ~ 1,
    num_periods_cells %in% c(1,2) ~ 0)) %>% 
  ungroup() %>% group_by(dataset) %>% 
  select(dataset, cell_grouping, cell_label, num_periods_cells, repeated) %>% unique()

presence_data_rep <- full_join(presence_data2, common_cells)

# Species sampled twice in the remaining cells
common_sp <- presence_data_rep %>% filter(repeated == 1 & cell_grouping == 1) %>% 
    group_by(dataset, verbatim_name) %>%
    summarise(num_periods_sp = n_distinct(tp)) %>% 
  ungroup() %>% group_by(dataset, num_periods_sp)

presence_data3 <- full_join(presence_data_rep, common_sp) 
saveRDS(presence_data3, paste0(out_path, "rds/presence_data_reduced.rds"))

presence_data3_red <- presence_data3 %>% filter(repeated == 1 & num_periods_sp == 2)
rm(common_cells, common_sp, presence_data_rep, presence_data2)

```

# Read & Process Grids

```{r}

# make list with names of layers so we can read them in below
layers_list <- list()
for (i in seq_along(grid_paths)){
  layers <- st_layers(grid_paths[i])$name
  layers_list[[i]] <- layers
  }
names(layers_list) <- atlas_names

# read grids to list
grid_list2 <- list()
for (a in seq_along(grid_paths)) {
    grid_list <- sapply(layers_list[[a]], function(i) {
      st_read(grid_paths[[a]], paste(i), quiet = TRUE) %>% 
        st_transform(crs = 4326) %>% reorder_levels( cell_grouping, order=desired_levels)
      }, simplify = FALSE)
    grid_list2[[a]] <- grid_list
    }

# clear space
rm(grid_list, a, layers, layers_list)

```

# Calculate variables

## Calculate occupancy (AOO)

Here we calculate several predictors for the atlases:

-   total sampled area per time period

-   total number of sampled cells per time period

```{r, calculate occupancy short version, message =F}

pres_dat_full1 <- list()
pres_dat_full3 <- list()

for (n_atlas in seq_along(atlas_names)){
  atlas_name <- atlas_names[n_atlas] # set variable for current run of the loop
  atlas <- grid_list2[[n_atlas]]# subset list of atlases to one
  
  for (grain in seq_along(atlas)){
    # set some variables for current run of the loop
    grain_a <- names(atlas)[grain]
    grain_d <- as.numeric(gsub("\\D", "", grain_a)) # "\\D" = remove all non-numbers
    
    # subset atlas to one grain
    atlas_1scale <- atlas[[grain]] %>% 
      select(cell_grouping, cell_label, area, cell_long, cell_lat) %>%
      st_drop_geometry()
    
    # Calculate total sampled area per time period:
    atlas_1scale <- atlas_1scale %>% 
      group_by(cell_grouping) %>%
      mutate(Total_area = sum(atlas_1scale$area))
    
    # Calculate total number of total cells sampled:
    Total_Ncells_samp <- presence_data3_red %>% filter(dataset == atlas_name & cell_grouping == grain_d) %>%
      select(dataset, cell_grouping, cell_label) %>% unique() %>% 
      group_by(dataset, cell_grouping) %>% summarise(n_cells = n_distinct(cell_label)) %>% 
      pull(n_cells) %>% unique()
    
    # Calculate total number of total cells per atlas:
    Total_Ncells_atlas <- atlas_1scale %>%
      group_by(cell_grouping) %>%
      mutate(Total_Ncells = length(unique(cell_label))) %>%
      pull(Total_Ncells) %>%
      unique()
    
    atlas_1scale$Total_Ncells_samp <- Total_Ncells_samp
    atlas_1scale$Total_Ncells_atlas <- Total_Ncells_atlas
    map_atlas_1scale <- atlas_1scale
    
    # subset the presence/absence data to the current spatial grain:
    pres_data_1atlas <- presence_data3_red %>% 
      filter(dataset == atlas_name) %>%
      filter(cell_grouping == grain_d) %>%
      select(dataset, tp, verbatim_name, samp_effort_type, effort, cell_label, cell_grouping, repeated)
  
    # Merge sampled and unsampled cells for calculations:
    pres_data_full_1atlas <- left_join(map_atlas_1scale, pres_data_1atlas)
    pres_data_full_1atlas %>% filter(!is.na(verbatim_name))
    pres_data_full_1atlas$dataset <- atlas_names[n_atlas]
    pres_dat_full1[[grain]] <- pres_data_full_1atlas %>% unique() %>% filter(!is.na(verbatim_name))
    
  }
  
  pres_dat_full2 <- plyr::rbind.fill(pres_dat_full1, fill=T)
  pres_dat_full3[[n_atlas]] <- pres_dat_full2
  
}

pres_dat_full4 <- plyr::rbind.fill(pres_dat_full3, fill=T)
pres_dat_full4[pres_dat_full4 == "<NA>"] = NA #Fix NA issues in the data (takes a while.)


pres_dat_final <- pres_dat_full4 %>%  
  mutate(cell_grouping = factor(cell_grouping,levels = desired_levels),
        grain = case_when(
          dataset == atlas_names[1] ~ "10",
          dataset == atlas_names[2] ~ "5",
          dataset == atlas_names[3] ~ "20", 
          dataset == atlas_names[4] ~ "50")) %>% 
  filter(!is.na(verbatim_name))


saveRDS(pres_dat_final, paste0(out_path, "rds/presence_data_final.rds"))


### =============================================== ###
rm(pres_dat_full1, pres_dat_full2, pres_dat_full3, pres_dat_full4, pres_data_1atlas, pres_data_full_1atlas, map_atlas_1scale)
### =============================================== ###


occ_data <- pres_dat_final %>%
  ungroup() %>%
  group_by(dataset, tp, cell_grouping, verbatim_name) %>% distinct() %>%
# Calculate Occupancy:
  mutate(occupancy_area = sum(area),
         mean_area = mean(area)) %>%
  mutate(occupancy_Ncells = n_distinct(cell_label)) %>%
# Calculate AOO:
  mutate(AOO = occupancy_Ncells * mean(area)) %>%
# Calculate relative Occupancy:
  mutate(relative_occupancy_area = occupancy_area/Total_area) %>%
  mutate(relative_occupancy_Ncells = occupancy_Ncells/Total_Ncells_samp) %>% ungroup() %>%
  group_by(dataset, tp, cell_grouping) %>%
  mutate(total_SR_atlas = n_distinct(verbatim_name)) %>%
# Remove duplicated rows:
  distinct() 

occ_data$cell_grouping2 <- as.numeric(as.character(occ_data$cell_grouping))


# create scale column as a fraction of the full country:
occ_data_final <- occ_data %>% 
  ungroup() %>%
  group_by(dataset) %>%
  mutate(scale = ifelse(dataset %in% c(atlas_names[1]) & cell_grouping == "1", 1/64, NA)) %>%
  mutate(scale = ifelse(dataset %in% c(atlas_names[1]) & cell_grouping == "2", 1/32, scale)) %>%
  mutate(scale = ifelse(dataset %in% c(atlas_names[1]) & cell_grouping == "4", 1/16, scale)) %>%
  mutate(scale = ifelse(dataset %in% c(atlas_names[1]) & cell_grouping == "8", 1/8, scale)) %>%
  mutate(scale = ifelse(dataset %in% c(atlas_names[1]) & cell_grouping == "16", 1/4, scale)) %>%
  mutate(scale = ifelse(dataset %in% c(atlas_names[1]) & cell_grouping == "32", 1/2, scale)) %>%
  mutate(scale = ifelse(dataset %in% c(atlas_names[1]) & cell_grouping == "64", 1, scale)) %>%
  mutate(scale = ifelse(dataset %in% c(atlas_names[2:4]) & cell_grouping == "1", 1/128, scale)) %>%
  mutate(scale = ifelse(dataset %in% c(atlas_names[2:4]) & cell_grouping == "2", 1/16, scale)) %>%
  mutate(scale = ifelse(dataset %in% c(atlas_names[2:4]) & cell_grouping == "4", 1/32, scale)) %>%
  mutate(scale = ifelse(dataset %in% c(atlas_names[2:4]) & cell_grouping == "8", 1/16, scale)) %>%
  mutate(scale = ifelse(dataset %in% c(atlas_names[2:4]) & cell_grouping == "16", 1/8, scale)) %>%
  mutate(scale = ifelse(dataset %in% c(atlas_names[2:4]) & cell_grouping == "32", 1/4, scale)) %>%
  mutate(scale = ifelse(dataset %in% c(atlas_names[2:4]) & cell_grouping == "64", 1/2, scale)) %>%
  mutate(scale = ifelse(dataset %in% c(atlas_names[2:4]) & cell_grouping == "128", 1, scale))

occ_data_final %>% filter_all(any_vars(is.na(.))) # NAs in effort columns

### =============================================== ###
rm(occ_data)
### =============================================== ###

# save reduced version of this to file:

species_data <- occ_data_final %>% 
  select(dataset, tp, cell_grouping, scale, verbatim_name, Total_area, Total_Ncells_atlas, Total_Ncells_samp, 
         occupancy_area, occupancy_Ncells, AOO, relative_occupancy_area, relative_occupancy_Ncells, mean_area, total_SR_atlas, grain) %>%
  distinct() 

species_data %>% write.csv(paste0(out_path, "csv/Occupancy_table.csv"))


```

## Occupancy-Area Relationship (OAR, D)

```{r, Saturated Species stats}

# Loop to prune species completely with less than 2 scales without saturation
atlas_names <- unique(species_data$dataset)
time_periods <- c(1,2)

list_sp <- list()
list_tp <- list()
list_a <- list()

for (a in seq_along(atlas_names)){
  temp_df <- species_data %>% filter(dataset == atlas_names[a])
  for (t in seq_along(time_periods)) {
    temp_df_t <- temp_df %>% filter(tp == time_periods[t])
    species_names <- unique(temp_df_t$verbatim_name)
    for (s in seq_along(species_names)){
      temp_df_s <- temp_df_t %>% filter(verbatim_name == species_names[s])
      
      # Exclude saturated scales
      temp_df_red <- temp_df_s %>% filter(relative_occupancy_Ncells < 1)
      
      if (nrow(temp_df_red) < 2) {
        out_df <- data.frame(verbatim_name = species_names[s],
                             dataset = atlas_names[a],
                             tp = time_periods[t],
                             exclude = 1,
                             available_scales = nrow(temp_df_red),
                             mean_relOcc = mean(temp_df_red$relative_occupancy_Ncells))
      } else if (nrow(temp_df_red) >= 2) {
        out_df <- data.frame(verbatim_name = species_names[s],
                             dataset = atlas_names[a],
                             tp = time_periods[t],
                             exclude = 0,
                             available_scales = nrow(temp_df_red),
                             mean_relOcc = mean(temp_df_red$relative_occupancy_Ncells))
      } else {
                out_df <- data.frame(verbatim_name = species_names[s],
                             dataset = atlas_names[a],
                             tp = time_periods[t],
                             exclude = NA,
                             available_scales = nrow(temp_df_red),
                             mean_relOcc = mean(temp_df_red$relative_occupancy_Ncells))
                }
      list_sp[[s]] <- out_df
    
      }
    sp_df <- plyr::rbind.fill(list_sp)
    list_tp[[t]] <- sp_df
  
    }
  tp_df <- plyr::rbind.fill(list_tp)
  list_a[[a]] <- tp_df
  }
atlas_df <- plyr::rbind.fill(list_a)
sp_data_new <- full_join(species_data, atlas_df)

```

```{r OAR}
dd <- sp_data_new %>%
  filter(exclude == 0) %>%
  filter(relative_occupancy_Ncells < 1) %>% # exclude saturated scales
  unique() %>%
  filter_at(vars(c(
      cell_grouping, scale,
      AOO, occupancy_Ncells,
      relative_occupancy_Ncells, mean_area)), any_vars(!is.na(.)))

## Variables:
atlas_names <- unique(dd$dataset)
period <- c(1,2)
OAR_list_sp <- list()
OAR_list_sp_tp <- list()
OAR_list_sp_tp_atlas <- list()

## Loop:
for (n_atlas in seq_along(atlas_names)){
  atlas_name <- atlas_names[n_atlas]
  atlas <- dd %>% filter(dataset == atlas_name)
  for (time in seq_along(period)){
    period_nr <- period[time]
    atlas_1time <- atlas %>% filter(tp == period_nr) 
    sp <- unique(atlas_1time$verbatim_name)
    for(spec in seq_along(sp)){
      species <- sp[spec]
      model_df <- atlas_1time %>% filter(verbatim_name == species) %>% distinct()

      OAR <- lm(log(AOO) ~ log(mean_area), data = model_df)
      
      OAR_df <- data.frame(
        verbatim_name = species,
        dataset = atlas_name,
        tp = period_nr,
        m_AOO_a = OAR$coefficients[2],
        b_AOO_a = OAR$coefficients[1])
      
      OAR_df$D_AOO_a <- -2*OAR_df$m_AOO_a+2
      OAR_df$dataset <- as.factor(OAR_df$dataset)
      OAR_list_sp[[spec]] <- OAR_df
      
    }
    
    OAR_df_sp <- plyr::rbind.fill(OAR_list_sp, fill = T)
    OAR_list_sp_tp[[time]] <- OAR_df_sp
     
  }
  OAR_df_sp_tp <- plyr::rbind.fill(OAR_list_sp_tp, fill = T)   
  OAR_list_sp_tp_atlas[[n_atlas]] <- OAR_df_sp_tp
}
    
OAR_final <- plyr::rbind.fill(OAR_list_sp_tp_atlas, fill = T) %>% distinct()
OAR_final %>% filter_all(any_vars(is.na(.))) # None !#


species_data_new <- merge(sp_data_new, 
                          OAR_final, 
                          by=c(intersect(names(species_data), names(OAR_final))), all = T) %>% distinct()

### =============================================== ###
rm(dd, OAR_list_sp_tp_atlas, OAR_list_sp_tp, OAR_df_sp_tp, OAR_list_sp, OAR_df_sp, OAR_df, sp, atlas_1time, model_df )
### =============================================== ###

```

## Telfer Index of change (not static)

```{r, telfer calculation}

# Telfer:
telfer_res <- list()
for (i in seq_along(atlas_names)){
  df <- pres_dat_final %>% filter(dataset == atlas_names[i]) %>% distinct()
  telfer <- sparta::telfer(taxa = df$verbatim_name,
                         site = df$cell_label,
                         time_period = df$tp,
                         minSite = 1)
telfer$dataset <- atlas_names[i]
telfer_res[[i]] <- telfer
  
}

telfer_res_df <- plyr::rbind.fill(telfer_res, fill = T) %>% distinct() %>%
  select(taxa, Telfer_1_2, dataset) %>% 
  rename(verbatim_name = taxa)%>%
  reorder_levels(dataset, order = atlas_names)


species_data_new2 <- left_join(species_data_new, telfer_res_df)

```

## Log Ratio (Temporal Change = Response)

### Make wide-format

```{r, make wide format}

# Re-formating the data.. there is probably a smoother way to do it..
species_data_wide1 <- species_data_new2 %>% 
  select(verbatim_name, tp, cell_grouping, 
         D_AOO_a, m_AOO_a,
         AOO, 
         Total_Ncells_samp, mean_area,
          occupancy_Ncells, 
         relative_occupancy_Ncells, dataset) %>% 
  group_by(dataset, verbatim_name, tp) %>% 
  distinct() %>% 
  filter(tp == 1) %>% 
  setNames(paste0('tp1_', names(.))) %>% 
  ungroup() %>%
  select(-c(tp1_tp)) %>%
  rename(verbatim_name = tp1_verbatim_name,
         cell_grouping = tp1_cell_grouping, 
         dataset = tp1_dataset)

species_data_wide2 <- species_data_new2 %>% 
  select(verbatim_name, tp, cell_grouping, 
         D_AOO_a, m_AOO_a,
         AOO, 
         Total_Ncells_samp, mean_area,
          occupancy_Ncells, 
         relative_occupancy_Ncells, dataset) %>% 
  group_by(dataset, verbatim_name, tp) %>% 
  distinct() %>% 
  filter(tp == 2) %>% 
  setNames(paste0('tp2_', names(.))) %>% 
  ungroup() %>%
  select(-c(tp2_tp)) %>%
  rename(verbatim_name = tp2_verbatim_name,
         cell_grouping = tp2_cell_grouping, 
         dataset = tp2_dataset)

# merge back together:
temp <- merge(species_data_wide1, species_data_wide2, 
              by=intersect(names(species_data_wide1), names(species_data_wide2)), all = T)
names_v <- names(temp)[-(1:3)] # remove verbatim_name, cell_grouping and dataset columns

# Transform to wide format by cell_grouping
species_data_wide <- temp %>% 
  pivot_wider(names_from = cell_grouping,
              values_from = all_of(names_v)) %>% unique()

### =============================================== ###
rm(species_data_wide1, species_data_wide2, temp, names_v)
### =============================================== ###


```

### Calculate Log Ratio

```{r, temporal change}
# Calculate log-Ratio of AOO (Temporal change)
log_ratio_data <- species_data_wide %>% 
  mutate(log_R2_1 = log(tp2_AOO_1/tp1_AOO_1)) %>%
  select(dataset, verbatim_name, log_R2_1)

species_data_bigtable <- merge(species_data_new2, log_ratio_data, by=c("verbatim_name", "dataset"),all = T)
species_data_bigtable %>% write.csv(file=paste0(out_path, "csv/Big_table_CZ_JP_NY_EU.csv"))


Change_Data <- species_data_bigtable %>% 
  filter(!is.na(log_R2_1)) %>% 
  select(verbatim_name, dataset, log_R2_1) %>% 
  distinct() %>% 
  na.omit() %>%
  reorder_levels(dataset, order = atlas_names)


Change_Data %>% 
  write.csv(paste0(out_path, "csv/Change_Data.csv"))

### =============================================== ###
#rm(species_data_new2, log_ratio_data)
### =============================================== ###

```
