---
title: "Geometries EBBA"
format: html
---


```{r}
rm(list=ls())
gc()

# Essential data wrangling packages:
library(dplyr) # Data wrangling
library(rstatix) # Reorder levels function
# library(plyr) (required but will be called individually for each function because of incompatibilities with dpylr functions)

# Phylogenetic stuff:
library(ape);library(phyloregion)
library(fossil) # Co occurrence

# Spatial stuff:
library(sf); sf_use_s2(FALSE) # Spatial stuff 1

### The paths =================================================
source_atlas <- c("c:/Users/wolke/OneDrive - CZU v Praze/Datasets/Processed/Atlases/Replicated/")
source_predictors <- c("c:/Users/wolke/OneDrive - CZU v Praze/Dokumenty/PhD_Projects/StaticPredictors/Data/")
source_Git <- c("c:/Users/wolke/OneDrive - CZU v Praze/Dokumenty/GitHub/BEAST_General_Procedures/Project_Frieda/StaticPredictors/")
out_path <- c(paste0(source_Git, "out/"))

# folder path to atlas data
source_paths <- c(
  paste0(source_atlas, "Birds_Atlas_Czechia/"),
  paste0(source_atlas, "Birds_Atlas_New_York/"),
  paste0(source_atlas, "Birds_atlas_Japan/"),
  paste0(source_atlas, "Birds_atlas_EBBA/")
)

# create path to read in data and grids from variables
data_paths <- c(paste0(source_paths[1],"Birds_Atlas_Czechia_beast_data.rds"), 
                paste0(source_paths[2], "Birds_Atlas_New_York_beast_data.rds"), 
                paste0(source_paths[3], "Birds_atlas_Japan_beast_data.rds"),
                paste0(out_path, "rds/EBBA_change_new.rds"))

grid_paths <- c(
  paste0(source_paths[1], "Birds_Atlas_Czechia_grid.gpkg"),
  paste0(source_paths[2], "Birds_Atlas_New_York_grid.gpkg"),
  paste0(source_paths[3], "Birds_atlas_Japan_grid.gpkg"),
  paste0(source_paths[4], "Birds_atlas_EBBA_grid.gpkg")
)

# Important vectors  =================================================
time_periods <- c(1,2)
atlas_names <- c("Birds_Atlas_Czechia", "Birds_Atlas_New_York","Birds_atlas_Japan", "Birds_atlas_EBBA")
desired_levels <- factor(c("1", "2", "4", "8", "16", "32", "64", "128"), ordered = T,
  levels = c("1", "2", "4", "8", "16", "32", "64", "128"))



# Define CRS for each region
crs_list <- list( "EPSG:5514", # CZ
                  "EPSG:32118", # NY
                  "EPSG:6668", # JP
                  "EPSG:3035") # EU
names(crs_list) <- c("CZ", "NY", "JP", "EU")

## We need the highest resolution data = cell_grouping = 1

# grid data =====================
grids <- list()
for (a in seq_along(grid_paths)) {
    grids_a <-sapply("cell1grid", function(i) {
      st_read(grid_paths[[a]], paste(i), quiet = TRUE)  %>% 
        st_transform(crs = crs_list[[a]]) %>% 
        reorder_levels( cell_grouping, order=desired_levels)
      }, simplify = FALSE)
    grids[[a]] <- grids_a$cell1grid
}

# Species data  =====================
presence_data_all <- list()
for (i in seq_along(data_paths)) {
  pres_dat <- readRDS(data_paths[i])
  sy <- sort(unique(pres_dat$start_year)) # sy = start_year

  ## Add time-period column
  pres_dat2 <- pres_dat %>% 
    mutate(tp = case_when(start_year == sy[1] ~ 1,
                          start_year == sy[2] ~ 2)) %>% 
    filter(tp %in% c(1,2)) %>%
    filter(!is.na(cell_label)) %>%
    reorder_levels(cell_grouping, order=desired_levels)

  ## Cells sampled twice (column: repeated)
  common_cells <- pres_dat2 %>%
    ungroup() %>%
    group_by(dataset, cell_grouping, cell_label) %>%
    mutate(num_periods_cells = n_distinct(tp)) %>%
    mutate(repeated = case_when(
      num_periods_cells == 2 ~ 1,
      num_periods_cells %in% c(1, 2) ~ 0
    )) %>%
    ungroup() %>%
    group_by(dataset) %>%
    select(dataset, cell_grouping, cell_label, num_periods_cells, repeated) %>%
    unique()

  common_cells %>%
    group_by(dataset, cell_grouping, repeated, num_periods_cells) %>%
    summarise(n = n())

  presence_data_rep <- full_join(pres_dat2, common_cells)

  # Species sampled twice in the remaining cells
  common_sp <- presence_data_rep %>%
    filter(repeated == 1 & cell_grouping == 1) %>%
    group_by(dataset, verbatim_name) %>%
    summarise(num_periods_sp = n_distinct(tp)) %>%
    ungroup() 
  presence_data3 <- full_join(presence_data_rep, common_sp) 

  presence_data_all[[i]] <- presence_data3
}

# saveRDS(presence_data_all, paste0(out_path, "rds/presence_data_all.rds"))

# Create list of spatial objects ==========================
presence_sf_list <- list()
for (a in seq_along(atlas_names)){
  grid <- grids[[a]]
  presence_data <- presence_data_all[[a]] %>% filter(!is.na(cell_label))
  presence_sf <- left_join(grid, presence_data)
  dd <- presence_sf %>% filter(dataset == atlas_names[a])
  presence_sf_list[[a]] <- dd 
  }

# saveRDS(presence_sf_list, paste0(out_path, "rds/presence_sf_list.rds"))

pacman::p_load(geosphere, geodata, terra, tidyterra)

# Function to get the max elongation per polygon, north-south length or east-west length, circularity, etc...
poly_attr <- function(x, type = NULL) {
  # Convert "sf" to SpatVector
  if (inherits(x, "sf") == T) {
    x <- vect(x)
  }
  # Reproject to WGS84. Currently, "terra" calculate distance in meters when given latitude and longitude points.
  x <- project(x, "epsg:4326")
  # Get East-West distance (longitudinal extension)
  if (type == "ewDist") {
    vert <- crds(as.points(ext(x)), df = T)
    dimNames <- list(c("point"),c("x","y"))
    sw <- matrix(c(min(vert[["x"]]), min(vert[["y"]])), ncol = 2, dimnames = dimNames)
    se <- matrix(c(max(vert[["x"]]), min(vert[["y"]])), ncol = 2, dimnames = dimNames)
    res <- distance(sw, se, lonlat = T)[[1]]
  }
  # Get South-North distance (latitudinal extension)
  if (type == "nsDist") {
    vert <- crds(as.points(ext(x)), df = T)
    dimNames <- list(c("point"),c("x","y"))
    sw <- matrix(c(min(vert[["x"]]), min(vert[["y"]])), ncol = 2, dimnames = dimNames)
    nw <- matrix(c(min(vert[["x"]]), max(vert[["y"]])), ncol = 2, dimnames = dimNames)
    res <- distance(sw, nw, lonlat = T)[[1]]
  }
  # Get max distance between opposite vertices
  if (type == "maxDist") {
    vert <- crds(as.points(convHull(x)))
    res <- distance(vert, lonlat = T) %>% max()
  }
  # Get elongation ratio along longest axis
  if (type == "elonRatio") {
    convexHull <- convHull(x)
    vert <- crds(as.points(convexHull), df = T)
    dist <- as.data.frame.table(as.matrix(distance(vert, lonlat = T)), responseName = "distance") %>%
      slice_max(., distance)
    axisPoints <- vert[c(dist[[1]][[1]],dist[[2]][[1]]),]
    axisPoints <- arrange(axisPoints, desc(y))
    rotation <- -1*bearing(axisPoints[2,],axisPoints[1,])
    rotHull <- spin(convexHull, rotation)
    ext <- ext(convexHull)
    df <- as.vector(distance(crds(as.points(ext)), lonlat = T))
    df <- sort(df)
    length <- mean(df[[3]], df[[4]])
    width <- mean(df[[1]], df[[2]])
    res <- 1 - (width / length)
    # res <- list()
    # res[["vert"]] <- vert
    # res[["dist"]] <- dist
    # res[["axispoints"]] <- axisPoints
    # res[["bearing"]] <- rotation
    # res[["rotHull"]] <- rotHull
  }
  # Circularity
  if (type == "circ") {
    perimeter <- perim(x)
    area <- expanse(x)
    res <- (perimeter^2) / area
  }
  # Normalized circularity
  if (type == "circNorm") {
    perimeter <- perim(x)
    area <- expanse(x)
    res <- (perimeter^2) / (4 * pi * area)
  }
  # Major length of the minimum rectangle
  if (type == "lengthMinRect") {
    minRectangle <- minRect(x)
    df <- as.vector(distance(crds(as.points(minRectangle), df = T), lonlat = T))
    df <- sort(df)
    res <- mean(df[[3]], df[[4]])
  }
  # Width of the minimum rectangle
  if (type == "widthMinRect") {
    minRectangle <- minRect(x)
    df <- as.vector(distance(crds(as.points(minRectangle), df = T), lonlat = T))
    df <- sort(df)
    res <- mean(df[[1]], df[[2]])
  }
  # Elongation ratio of minimal encasing rectangle (from here: Dražić, S., Ralević, N., & Žunić, J. (2010). Shape elongation from optimal encasing rectangles. Computers & Mathematics with Applications, 60(7), 2035–2042. https://doi.org/10.1016/j.camwa.2010.07.043)
  if (type == "elonMinRect") {
    minRectangle <- minRect(x)
    df <- as.vector(distance(crds(as.points(minRectangle)), lonlat = T))
    df <- sort(df)
    length <- mean(df[[3]], df[[4]])
    width <- mean(df[[1]], df[[2]])
    res <- 1 - (width / length)
  }
  # Related circumscribing circle
  if (type == "relCirc") {
    circle <- minCircle(x)
    areaCircle <- expanse(circle)
    area <- expanse(x)
    res <- 1-(area/areaCircle)
  }
  # Linearity index
  if (type == "lin") {
    hull <- convHull(x)
    df <- crds(as.points(hull), df = T)
    lm <- lm(y ~ x, data = df)
    res <- summary(lm)$r.squared
  }
  # North bearing of the minimum rectangle
  if (type == "bearingMinRect") {
    minRectangle <- minRect(x)
    df <- crds(as.points(minRectangle), df = T)
    cor <- cor(df[["x"]],df[["y"]])
    point1 <- slice_min(df, y)
    if (cor > 0){
      point2 <-slice_max(df, x)
    } else{
      point2 <-slice_min(df, x)
    }
    res <- bearing(point1, point2)
  }
    # Get bearing along longest axis
  if (type == "bearing") {
    convexHull <- convHull(x)
    vert <- crds(as.points(convexHull), df = T)
    dist <- as.data.frame.table(as.matrix(distance(vert, lonlat = T)), responseName = "distance") %>%
      slice_max(., distance)
    axisPoints <- vert[c(dist[[1]][[1]],dist[[2]][[1]]),]
    axisPoints <- arrange(axisPoints, desc(y))
    res <- bearing(axisPoints[2,],axisPoints[1,])
  }
  res <- as.numeric(res)
  return(res)
}


```

start:18:00
```{r}
tictoc::tic()
# Atlas Geometries ==============================================================
geom_ls <- list()
# grid data =====================
grids0 <- list()
for (a in seq_along(grid_paths)) {
    grids_a <-sapply("cell1grid", function(i) {
      st_read(grid_paths[[a]], paste(i), quiet = TRUE)  %>% 
        st_transform(crs = crs_list[[a]]) %>% 
        filter(!is.na(cell_long)) %>%
        reorder_levels( cell_grouping, order=desired_levels)
      }, simplify = FALSE)
    grids0[[a]] <- grids_a$cell1grid
}
grids <- grids0[1:3]

for (i in seq_along(grids)){
  
  Atlas_Geom <- grids[[i]] %>% 
    select(geom, cell_label) %>%
    summarise() %>% 
    terra::vect()
  
  Geom_attributes_atlas <- data_frame(dataset = atlas_names[i],
           atlas_nsDist = poly_attr(Atlas_Geom, "nsDist"),
           atlas_ewDist = poly_attr(Atlas_Geom, "ewDist"),
           atlas_maxDist = poly_attr(Atlas_Geom, "maxDist"),
           atlas_lengthMinRect = poly_attr(Atlas_Geom, "lengthMinRect"),
           atlas_widthMinRect = poly_attr(Atlas_Geom, "widthMinRect"),
           atlas_elonMinRect = poly_attr(Atlas_Geom, "elonMinRect"),
           atlas_elonRatio = poly_attr(Atlas_Geom, "elonRatio"),
           atlas_circ = poly_attr(Atlas_Geom, "circ"),
           atlas_circNorm = poly_attr(Atlas_Geom, "circNorm"),
           atlas_relCirc = poly_attr(Atlas_Geom, "relCirc"),
           atlas_lin = poly_attr(Atlas_Geom, "lin"),
           atlas_bearingMinRect = poly_attr(Atlas_Geom, "bearingMinRect"), 
           atlas_bearing = poly_attr(Atlas_Geom, "bearing"))
           
  ## Southernness/Westernness
  atlas_xmin <- st_bbox(Atlas_Geom)[1]
  atlas_ymin <- st_bbox(Atlas_Geom)[2]
  atlas_xmax <- st_bbox(Atlas_Geom)[3]
  atlas_ymax <- st_bbox(Atlas_Geom)[4]
  atlas_xhalf <- atlas_xmax+(atlas_xmin-atlas_xmax)/2
  atlas_yhalf <- atlas_ymax+(atlas_ymin-atlas_ymax)/2
  
  atlas_bbox <- data.frame(atlas_xmin, atlas_xmax, atlas_xhalf, atlas_ymin, atlas_ymax, atlas_yhalf)
  atlas_bbox$dataset <- atlas_names[i] 
  
  geom_ls[[i]] <- full_join(atlas_bbox, Geom_attributes_atlas)
  
}

countries_geom_attributes <- plyr::rbind.fill(geom_ls) 

# Transform country-borders to lines
lines_l <- list()

for (a in seq_along(grids)){
  lines <- grids[[a]] %>% 
    summarise() %>% 
    vect() %>% 
    as.lines()
  lines_l[[a]] <- lines
}

### For each species separately:

species_geom <- list()
year_species_geom <- list()
atlas_all_sp_geom <-list()
COG_all <- list()
COG_a <- list()
presence_sf_list0 <- presence_sf_list
presence_sf_list <- presence_sf_list0[1:3]

for (a in seq_along(presence_sf_list)){
  atlas <- presence_sf_list[[a]] %>% select(dataset, tp, cell_label, cell_long, cell_lat, verbatim_name, num_periods_cells, num_periods_sp)
  
  for (y in seq_along(time_periods)){
    atlas_y <- atlas %>% filter(tp == time_periods[y])
    sp <- unique(atlas_y$verbatim_name)
    
    # Calculate Center of Gravity of all species per atlas
    COG <- atlas_y %>% st_drop_geometry() %>% summarise(CenterOfGravity_Atlas_long = mean(cell_long),
                                 CenterOfGravity_Atlas_lat = mean(cell_lat),
                                 dataset = unique(dataset))
    COG_all[[y]] <- COG

    points_COG_atlas <- COG %>% 
      dplyr::select(CenterOfGravity_Atlas_long, CenterOfGravity_Atlas_lat, dataset) %>%
      rename("x" = "CenterOfGravity_Atlas_long", "y" = "CenterOfGravity_Atlas_lat") %>% 
      na.omit() %>% 
      distinct()
    
    
    points_atlas <- points_COG_atlas %>% vect(geom = c("x", "y"), crs = crs_list[[a]])
    
    for (s in seq_along(sp)){
      print(paste(atlas_names[i], time_periods[y], sp[s]))
      atlas_sp <- atlas_y %>% filter(verbatim_name == sp[s]) 
      
      ## Maybe I have to summarize here ! Not sure - let's try this and compare.
      COG_sp <- atlas_sp %>% 
        select(cell_long, cell_lat, verbatim_name, dataset, tp) %>%
        mutate(sp_COG_long = mean(cell_long), 
               sp_COG_lat = mean(cell_lat)) %>% 
        st_drop_geometry() %>% 
        select(-cell_long, -cell_lat) %>% 
        unique()
      
      points_COG_sp <- COG_sp %>%
        group_by(dataset, tp, verbatim_name) %>% 
        dplyr::select(sp_COG_long, sp_COG_lat, dataset, tp, verbatim_name) %>%
        rename("x" = "sp_COG_long", "y" = "sp_COG_lat") %>% na.omit() %>% ungroup()

      points2 <- points_COG_sp %>%
        vect(geom = c("x", "y"), crs = crs_list[[a]])
            
      test <- atlas_sp %>% 
        select(geom, cell_label)%>% 
        summarise() %>% 
        vect() 
    
      ## Calculate distance 
      atlas_lines <- lines_l[[a]]
      Dist_toCOG <- terra::distance(crds(points2), crds(points_atlas), lonlat = F)
      minDist_toBorder_centr <- min(distance(crds(points2), crds(atlas_lines), lonlat=F))
      maxDist_toBorder_centr <- max(distance(crds(points2), crds(atlas_lines), lonlat=F))
      minDist_toBorder <- min(distance(crds(test), crds(atlas_lines), lonlat=F))
      maxDist_toBorder <- max(distance(crds(test), crds(atlas_lines), lonlat=F))
    
      Geom_attributes <- data_frame(dataset = atlas_names[4],
                                    tp = time_periods[y],
                                    verbatim_name = sp[s],
                                    nsDist = poly_attr(test, "nsDist"),
                                    ewDist = poly_attr(test, "ewDist"),
                                    maxDist = poly_attr(test, "maxDist"),
                                    lengthMinRect = poly_attr(test, "lengthMinRect"),
                                    widthMinRect = poly_attr(test, "widthMinRect"),
                                    elonMinRect = poly_attr(test, "elonMinRect"),
                                    elonRatio = poly_attr(test, "elonRatio"),
                                    circ = poly_attr(test, "circ"),
                                    circNorm = poly_attr(test, "circNorm"),
                                    relCirc = poly_attr(test, "relCirc"),
                                    lin = poly_attr(test, "lin"),
                                    bearingMinRect = poly_attr(test, "bearingMinRect"), 
                                    bearing = poly_attr(test, "bearing"),
                                    Dist_toCOD = Dist_toCOG,
                                    minDist_toBorder = minDist_toBorder,
                                    maxDist_toBorder = maxDist_toBorder,
                                    minDist_toBorder_centr = minDist_toBorder_centr,
                                    maxDist_toBorder_centr = maxDist_toBorder_centr)
        
        Geom_attributes2 <- full_join(Geom_attributes, COG_sp) %>% unique()
        
        species_geom[[s]] <- Geom_attributes2
        }
    
    species_geom_df <- plyr::rbind.fill(species_geom)  
    year_species_geom[[y]] <- species_geom_df  
    }
  COG_a[[a]] <- plyr::rbind.fill(COG_all)
  year_species_geom_df <- plyr::rbind.fill(year_species_geom) 
  atlas_all_sp_geom[[a]] <- year_species_geom_df
  }

COG_df <- plyr::rbind.fill(COG_a)
Species_geom_attributes <- plyr::rbind.fill(atlas_all_sp_geom) 

Atlas_geom <- full_join(countries_geom_attributes, COG_df) %>% group_by(dataset) %>% distinct(dataset, .keep_all=T)
Geometries <- full_join(Species_geom_attributes, Atlas_geom, relationship = "many-to-many") %>% distinct()

# Southerness/Westerness =================================
Southernness_Westernness <- Geometries %>% 
  group_by(dataset, tp, verbatim_name) %>% 
  select(dataset, tp, verbatim_name, sp_COG_long, sp_COG_lat, atlas_xmin, atlas_xmax, atlas_xhalf, atlas_ymin, atlas_ymax, atlas_yhalf) %>% 
  unique() %>%
  summarize(Southernness = 1-((sp_COG_lat - atlas_ymin)/((atlas_ymax -atlas_ymin))),
            Westernness = 1-((sp_COG_long - atlas_xmin)/((atlas_xmax-atlas_xmin)))) %>% ungroup() 

Geometries_final <- left_join(Geometries, Southernness_Westernness, relationship = "many-to-many") %>% distinct(dataset, tp, verbatim_name, .keep_all = T)


saveRDS(Geometries_final, paste0(out_path, "rds/Geometries_EBBA_v2.rds"))

tictoc::toc()

colSums(is.na(Geometries_final))
```

